= Purpose of this program =

Create makefiles for a non-recursive make setup from simple descriptor
files.

See:
    Recursive Make Considered Harmful
    http://miller.emu.id.au/pmiller/books/rmch/

    Implementing non-recursive make
    http://www.xs4all.nl/~evbergen/nonrecursive-make.html


This program assumes that you have your code distributed into a tree
of directories and that the top-level directory does not contain any
source code files.

TOP-DIR/
      makefile [master-makefile]
      foo/
         build.rules
         foo1.cpp foo2.cpp
      bla/
         build.rules
         bla1.cpp bla2.cpp
         blub/
            build.rules
            blub1.cpp blub2.cpp

When started in TOP-DIR this program will recurse through all
sub-directories and generate a makefile whenever it finds a build
descriptor file (build.rules).

Furthermore in the top-level directory the file 'makefile.dirs' will
be created; the purpose is to include all sub-makefiles.

If the master-makefile does not exist, it will be created as well.


= A quick example =

Any file 'build.rules' can contain an arbitrary number of target
descriptions; at this time this can be either a program or a library.

In this case there would be only a single directory and one build
descriptor file.

-- Example: build.rules --
program "ProjectA" {
    src = *.cpp
    depends = libprjb
    ld-flags = -lz
}

library "libprjb" {
    src = *.cxx
    flags = -DUSE_FEATURE_X
}
-- end of build.rules --

These rules would result in the following pseudo-make rules:

SRC_A = $(wildcard *.cpp)
OBJ_A = $(SRC_A:%.cpp=%.o)
SRC_B = $(wildcard *.cxx)
OBJ_B = $(SRC_B:%.cxx=%.o)

foreach o in $(OBJ_B):
   add -DUSE_FEATURE_X to CXXFLAGS

libprjb: $(OBJ_B)
   link $@ $^

ProjectA: $(OBJ_A) libprjb
   link $@ $^ -lz


= Descriptor language =


* Which source code files [mostly-required]

src = *.cpp
src = foo.cpp bar.cpp blub.cpp
src = $(A_MAKE_VARIABLE)

Note: If you use a variable expression you may also need to set
'extension = cxx' or something like that; this is required to
fill the OBJ_* and DEP_* variable substitutions.

Note: Something setting 'cmd = g++' (or whatever) might be needed
as well.

Under normal circumstances the file paths are assumed to be relative
to the respective 'build.rules' file; you may also request paths
resolution to be relative to the top-dir:
Example: src = foo.cpp bar.cpp ! file/in/a/subdir/blub.cpp


* Additional object files [optional]

extra-obj = foo.o bla.o

There may be situations when a single source/object file is used in
multiple targets; in this case you should always refer to the compiled
objects. Compiling the same file multiple times confuses the dependency
management.

This also means that you *cannot* compile a single file with different
C[XX]FLAGS for different targets.

'extra-obj' supports the same value-syntax as 'src'.


* Depend on other targets [optional]

depends = foo bar baz

The dependency can only be a library; you only have to to
use the name, there is no need to give relative pathes to the
actual library directory.

Note: As a corollary this means that library (and program) names
have to be unique!

The depending target will be linked against all dependencies; furthermore
the path to each dependency will be added as -Isome/path to the compile
flags when compiling the corresponding objects. [see 'export-inc']

If a dependency exists as both a static and a shared library the latter
will be used.


* Additional compiler/linker flags [optional]

flags = -I/opt/something/else -D_GNU_SOURCE
ld-flags = -Wl,-Bsymbolic


* Other switches [optional]

Do not install into DESTDIR:
skip-install = true

Only build a static library version:
skip-shared = true

Only build a shared library version:
skip-static = true

Shared-library version number
version-info = x.y.z
version-number = x.y.z

See: http://www.gnu.org/software/libtool/manual/html_node/Link-mode.html


* External software as dependency

Warning: This feature is EXPERIMENTAL!

You need to define/modify the following variables (in make.conf)

STAGEDIR := $(TOP)/third_party/stagedir
INC      += -I$(STAGEDIR)/include
CONFIGURE_MAKE_INSTALL := ./configure --prefix $(STAGEDIR) && make install


-- Example: build.rules --
external "libglog" {
    src     = glog-0.3.1-1.tar.gz
    src-dir = glog-0.3.1
    depends = libev
}

external "libev" {
    src = libev-4.04.tar.gz
}
-- end of build.rules --

Both 'depends' and 'src-dir' are optional; depends only forces the build-
order of the external projects; src-dir is required if the root-directory
name (in the tar.gz) cannot be guessed from the filename.

Note: this is only tested for projects that use autoconf/make; at least one
library should be generated by the external build process.


* missing documentation for...

FIXME:

dest-dir = ...
export-inc = ...
convenience = true

skip-if XXX

VERBATIM section

per-module XXX_DIR variable; where XXX is the last-dir-component

= Crosscompiling with mingw =

http://www.gnu.org/software/libtool/
./configure --prefix ... \ 
  --host=i586-mingw32msvc --program-prefix=i586-mingw32msvc-

In 'make.conf'

WIN32 := 1
LIBTOOL := /path/tok/i586-mingw32msvc-libtool
CXX := i586-mingw32msvc-g++
