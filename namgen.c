#include <stdlib.h>
#include <assert.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <dirent.h>
#include <stdio.h>
#include <getopt.h>
#include <libgen.h>
#include <sys/types.h>
#include <sys/stat.h>

#include "myio.h"
#include "utlist.h"
#include "ngtemplate.h"
#include "stringbuilder.h"
#include "dirscanner.h"
#include "target.h"
#include "template.h"
#include "logging.h"

static ngt_template *template = NULL;
static char *template_file = COMPILED_IN_TEMPLATE_FILE; 

char *top_dir = NULL;

static int process_module(module_entry *module)
{
   DEBUG("Creating %s/makefile\n", module->directory);
   char *output_str = NULL;
   int res = 0;

   if (chdir(module->directory))
      return 1;
   ngt_dictionary *dict = dict_for_module(module);
   ngt_set_dictionary(template, dict);
   ngt_expand(template, &output_str);
   int fd = open("makefile", O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
   int wl = strlen(output_str);
   if (write(fd, output_str, wl) != wl)
   {
      fprintf(stderr, "Error while writing '%s/makefile'\n",
            module->directory);
      res = 1;
   }
   close(fd);
   if (dict)
      ngt_dictionary_destroy(dict);
   if (output_str)
      free(output_str);

   return res;
}

static void usage(const char * prg)
{
    char *_prg = strdup(prg);
    char *name = basename(_prg);
    printf("USAGE: %s [flags]\n", name);
    free(_prg);
    name = load_file("usage.txt");
    if (name)
    {
        printf("%s\n", name);
        free(name);
    } else
    {
        fprintf(stderr, "Failed to load usage.txt\n");
    }
}

static void show_documentation(void)
{
    char *doc = load_file("documentation.txt");
    if (doc)
    {
        printf("%s\n", doc);
        free(doc);
    } else
    {
        fprintf(stderr, "Failed to load documentation.txt\n");
    }
}

struct charp_list_entry;
typedef struct charp_list_entry {
    char *dir;
    struct charp_list_entry *next;
} charp_list_entry;

static charp_list_entry* make_list_entry(char *dir)
{
    charp_list_entry *e = malloc(sizeof(charp_list_entry));
    int k = strlen(dir) - 1;
    if (dir[k] == '/')
       dir[k] = 0;
    e->dir = dir;
    e->next = NULL;
    return e;
}


static int module_cmp(module_entry *a, module_entry *b)
{
    return strcmp(a->path_from_top, b->path_from_top);
}

static void create_master_include(void)
{
    if (chdir(top_dir))
    {
        fprintf(stderr, "Could not change to dir: %s\n", top_dir);
        return;
    }
    FILE *f = fopen("makefile.dirs", "w");
    fprintf(f, "# This file was generated by namgen; do not edit!\n\n");

    module_entry *modules, *me;
    modules = get_module_list();
    LL_SORT(modules, module_cmp);
    LL_FOREACH(modules, me)
    {
        if (me->skip_condition)
        {
            fprintf(f, "ifndef %s\n", me->skip_condition);
        }
        fprintf(f, "include %s/makefile\n", me->path_from_top);
        fprintf(f, "ALL_CLEAN_TARGETS += %s_clean\n", me->dir_name);
        fprintf(f, "ALL_INSTALL_TARGETS += %s_install\n", me->dir_name);
        fprintf(f, "ALL_UNINSTALL_TARGETS += %s_uninstall\n", me->dir_name);
        if (me->skip_condition)
        {
            fprintf(f, "endif\n");
        }
        fprintf(f, "\n");
    }
    fprintf(f, "\n");

    fprintf(f, "clean: $(ALL_CLEAN_TARGETS)\n");
    fprintf(f, "install: $(ALL_INSTALL_TARGETS)\n");
    fprintf(f, "uninstall: $(ALL_UNINSTALL_TARGETS)\n");

    fprintf(f, ".PHONY: $(ALL_CLEAN_TARGETS) $(ALL_INSTALL_TARGETS) $(ALL_UNINSTALL_TARGETS)\n");
    fclose(f);
}

static void safe_export_file(const char *name, int make_executable)
{
    // assume that we are back in top_dir

    // don't overwrite if already exists
    if (!access(name, F_OK))
    {
        DEBUG("File %s exists, skipping\n", name);
        return;
    }
    FILE *f = fopen(name, "w");
    if (!f)
    {
        fprintf(stderr, "Error opening file %s for writing\n", name);
        return;
    }
    char *data = load_file(name);
    if (data)
    {
        fprintf(f, "%s", data);
    } else
    {
        fprintf(stderr, "Error loading src file %s\n", name);
    }
    fclose(f);
    if (make_executable)
    {
        chmod(name, S_IRWXU | S_IRWXG | S_IROTH);
    }
    DEBUG("Created base-file %s\n", name);
    if (data)
        free(data);
}

static void print_loaded_rules(void)
{
   module_entry *modules, *me;
   modules = get_module_list();
   LL_FOREACH(modules, me)
   {
      target_entry *te;
      LL_FOREACH(me->targets, te)
      {
         print_target_decl(te);
      }
      if (me->verbatim)
      {
         printf("Module '%s' has verbatim data:\n%s------------------------\n",
               me->dir_name, me->verbatim);
      }
   }
}

extern void install_bt_handler(void);

int main(int argc, char *argv[])
{
    int c, opt_idx;
    int print_rules = 0;
    int work_mode = 1;
    static struct option long_opts[] = {
        {"add-dir",  1, 0, 'a'},
        {"print",    0, 0, 'p'},
        {"help",     0, 0, 'h'},
        {"show-doc", 0, 0, 'H'},
        {"debug",    0, 0, 'd'},
        {"clean",    0, 0, 'C'},
        {0, 0, 0, 0}
    };
    charp_list_entry *additional_dir_list_head = NULL; 
    if (io_init(argv[0]))
    {
        fprintf(stderr, "Error loading IO subsystem for %s\n", argv[0]);
        exit(1);
    }

    while ((c = getopt_long(argc, argv, "a:dpCh?H", long_opts, &opt_idx)) != -1) {
        switch(c) {
            case 'a':
                LL_APPEND(additional_dir_list_head, make_list_entry(optarg));
                break;
            case 'p':
                print_rules = 1;
                break;
            case 'd':
                set_debug_on(1);
                break;
            case 'C':
                work_mode = -1;
                break;
            case 'h':
            case '?':
                usage(argv[0]);
                exit(0);
                break;
            case 'H':
                show_documentation();
                exit(0);
                break;
            default:
                usage(argv[1]);
                exit(1);
        }
    };

    install_bt_handler();
    
    top_dir = getenv("PWD"); 

    iterate_directories(top_dir, work_mode);
    if (additional_dir_list_head)
    {
        charp_list_entry *e, *n;
        LL_FOREACH(additional_dir_list_head, e)
        {
            iterate_directories(e->dir, work_mode);
        }

        // cleanup
        e = additional_dir_list_head;
        while (e) {
            n = e->next;
            free(e);
            e = n;
        }
    }
    if (work_mode == -1) {
        // cleanup other files
        if (chdir(top_dir))
        {
            fprintf(stderr, "Could not change to dir: %s\n", top_dir);
        } else
        {
            if (!access("makefile.dirs", R_OK))
            {
                unlink("makefile.dirs");
                unlink("install");
                unlink("makefile");
            }
        }
        goto work_skipped;
    }

    int missing = resolve_all_dependencies();
    if (!missing)
    {
       printf("Loaded: %i program rules and %i library rules in %i modules\n",
             program_count, library_count, module_count);
    } else
    {
       fprintf(stderr, "Error: missing %i dependencies\n", missing);
       if (!print_rules)
          exit(1);
    }

    if (print_rules)
    {
       print_loaded_rules();
       goto work_skipped;
    }

    template = ngt_new();

    if (load_template(template, template_file))
    {
        fprintf(stderr, "Error loading template %s\n", template_file);
        goto work_skipped;
    }

    module_entry *modules, *me;
    modules = get_module_list();
    LL_FOREACH(modules, me)
    {
       if (process_module(me))
          goto work_skipped;
    }

    create_master_include();
    safe_export_file("makefile", 0);
    safe_export_file("install", 1);

work_skipped:
    cleanup_data();
    template_cleanup();
    if (template)
        ngt_destroy(template);

    io_quit();
    return 0;
}
